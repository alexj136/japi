package parser;

import java_cup.runtime.ScannerBuffer;
import java_cup.runtime.ComplexSymbolFactory;
import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;
import syntax.*;
import utils.Pair;
import utils.Triple;
import java.util.ArrayList;
import java.util.HashMap;
import java.io.InputStream;
import java.io.InputStreamReader;

parser code {:
    public Parser(Lexer lexer, ComplexSymbolFactory csf) { super(lexer, csf); }

    public static Triple<PiTerm<Integer>, HashMap<String, Integer>, Integer>
            parseStream(InputStream input) throws Exception {

        ComplexSymbolFactory csf = new ComplexSymbolFactory();
        Lexer lexer = new Lexer(new InputStreamReader(input), csf);
        PiTerm<Integer> parsedTerm = (PiTerm<Integer>)
                (new Parser(new ScannerBuffer(lexer), csf).parse().value);
        Pair<HashMap<String, Integer>, Integer> nameInfo = lexer.getNameInfo();
        return Triple.make(parsedTerm, nameInfo.frst, nameInfo.scnd);
    }
:};

terminal            LANGLE, // <
                    RANGLE, // >
                    LPAREN, // (
                    RPAREN, // )
                    LSQUAR, // [
                    RSQUAR, // ]
                    LCURLY, // {
                    RCURLY, // }
                    DOT,    // .
                    COMMA,  // ,
                    BAR,    // |
                    SUM,    // +
                    NEW,    // new
                    IN,     // in
                    BANG,   // !
                    ZERO,   // 0
                    BSLASH, // \
                    ARROW,  // ->
                    APP;    // PRECEDENCE DECLARATOR
terminal Integer    IDENT;  // [a-z_]+

/* The pi-calculus grammar used is as follows:
 *
 * P ::= "x(a0, a1, ... aN).P" | "x<E0, E1, ... EN>.P" | "[P0|P1|...PN]"
 * | "new x in P" | "!P" | "{P0 + P1 + ... PN}" | "0"
 * E ::= "\x -> E" | "E E" | "x" | "( E )"
 */

non terminal PiTerm<Integer>                 piTerm;
non terminal ArrayList<PiTerm<Integer>>      parTerms;
non terminal ArrayList<PiTerm<Integer>>      moreParTerms;
non terminal ArrayList<PiTerm<Integer>>      sumTerms;
non terminal ArrayList<PiTerm<Integer>>      moreSumTerms;
non terminal LambdaTerm<Integer>             lamTerm;
non terminal ArrayList<LambdaTerm<Integer>>  lamTerms;
non terminal ArrayList<LambdaTerm<Integer>>  moreLamTerms;
non terminal ArrayList<Integer>              names;
non terminal ArrayList<Integer>              moreNames;

precedence left LPAREN;
precedence left BSLASH;
precedence left IDENT;
precedence left APP;

start with piTerm;

piTerm        ::= IDENT:c names:n DOT piTerm:s     {: RESULT = new Receive<Integer>(c, n, s);         :}
                | IDENT:c lamTerms:e DOT piTerm:s  {: RESULT = new Send<Integer>(c, e, s);            :}
                | parTerms:s                       {: RESULT = new Parallel<Integer>(s);              :}
                | NEW IDENT:c IN piTerm:s          {: RESULT = new Restrict<Integer>(c, s);           :}
                | BANG piTerm:s                    {: RESULT = new Replicate<Integer>(s);             :}
                | sumTerms:s                       {: RESULT = new NDSum<Integer>(s);                 :}
                | ZERO           {: RESULT = new Parallel<Integer>(new ArrayList<PiTerm<Integer>>()); :}
                ;

names         ::= LPAREN RPAREN                    {: RESULT = new ArrayList<Integer>();              :}
                | LPAREN IDENT:c moreNames:n       {: n.add(0, c); RESULT = n;                        :}
                ;

moreNames     ::= RPAREN                           {: RESULT = new ArrayList<Integer>();              :}
                | COMMA IDENT:c moreNames:n        {: n.add(0, c); RESULT = n;                        :}
                ;

lamTerms      ::= LANGLE RANGLE                    {: RESULT = new ArrayList<LambdaTerm<Integer>>();  :}
                | LANGLE lamTerm:s moreLamTerms:ss {: ss.add(0, s); RESULT = ss;                      :}
                ;

moreLamTerms  ::= RANGLE                           {: RESULT = new ArrayList<LambdaTerm<Integer>>();  :}
                | COMMA lamTerm:s moreLamTerms:ss  {: ss.add(0, s); RESULT = ss;                      :}
                ;

parTerms      ::= LSQUAR RSQUAR                    {: RESULT = new ArrayList<PiTerm<Integer>>();      :}
                | LSQUAR piTerm:s moreParTerms:ss  {: ss.add(0, s); RESULT = ss;                      :}
                ;

moreParTerms  ::= RSQUAR                           {: RESULT = new ArrayList<PiTerm<Integer>>();      :}
                | BAR piTerm:s moreParTerms:ss     {: ss.add(0, s); RESULT = ss;                      :}
                ;

sumTerms      ::= LCURLY RCURLY                    {: RESULT = new ArrayList<PiTerm<Integer>>();      :}
                | LCURLY piTerm:s moreSumTerms:ss  {: ss.add(0, s); RESULT = ss;                      :}
                ;

moreSumTerms  ::= RCURLY                           {: RESULT = new ArrayList<PiTerm<Integer>>();      :}
                | SUM piTerm:s moreSumTerms:ss     {: ss.add(0, s); RESULT = ss;                      :}
                ;

lamTerm       ::= LPAREN lamTerm:s RPAREN          {: RESULT = s;                                     :}
                | BSLASH IDENT:c ARROW lamTerm:s   {: RESULT = new Abstraction<Integer>(c, s);        :}
                | IDENT:c                          {: RESULT = new Variable<Integer>(c);              :}
                | lamTerm:s1 lamTerm:s2            {: RESULT = new Application<Integer>(s1, s2);      :} %prec APP
                ;
