PARSER_BEGIN(Parser)
package parser;

import syntax.*;
import java.io.File;
import java.io.InputStream;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.util.ArrayList;

public class Parser {

    /**
     * Parse some input to obtain an AST.
     * @param input a java.io.InputStream containing text (ideally) representing
     * a japi program
     * @return an AST (a PiTerm object) representing the parsed program
     * @throws ParseException if the input could not be parsed (i.e. if there
     * was a syntax error in the program)
     */
    public static PiTerm parseStream(InputStream input) throws ParseException {
        return new Parser(input).term();
    }
}

PARSER_END(Parser)

SKIP :
    { " "
    | "\t"
    | "\n"
    | "\r"
    | <"//" (~["\n","\r"])* ("\n" | "\r" | "\r\n")>
    | <"/*" (~[])* "*/">
    }

TOKEN :
    { "<"
    | ">"
    | "("
    | ")"
    | "."
    | "["
    | "|"
    | "]"
    | "{"
    | "+"
    | "}"
    | "new"
    | "in"
    | "!"
    | "0"
    | "\\"
    | "->"
    | <ID: (["a"-"z"])+>
    }

void input() : {} { term() <EOF> }

/* The pi-calculus grammar used is as follows:
 *
 *     P ::= "x(a0, a1, ... aN).P" | "x<E0, E1, ... EN>.P" | "[P0|P1|...PN]"
 *         | "new x in P" | "!P" | "{P0 + P1 + ... PN}" | "0"
 *     E ::= "\x -> E" | "E E" | "x"
 *
 * which, in a more concrete, non-left-recursive form is:
 *
 *     TERM         ::= "x(RECECONT . TERM" | "x<SENDCONT . TERM"
 *                    | "[ PARACONT" | "new x in TERM" | "!TERM"
 *                    | "{ TERM + TERM SUMCONT" | "0"
 *     SUMCONT      ::= "}" |  " + TERM SUMCONT"
 *     PARACONT     ::= "]" | "TERMSM PARACONTCONT"
 *     PARACONTCONT ::= "]" | "| TERMSM PARACONTCONT"
 *     RECECONT     ::= ")" | "y RCONTC"
 *     RECECONTCONT ::= ")" | ", y RCONTC"
 *     SENDCONT     ::= ">" | "LTM SENDCONTCONT"
 *     SENDCONTCONT ::= ">" | ", LTM SENDCONTCONT"
 *     LAMTERM      ::= "x LAMTERMOPT" | "\x -> LAMTERMOPT"
 *                    | "(LAMTERM) LAMTERMOPT"
 *     LAMTERMOPT   ::= "LAMTERM" | epsilon
 *
 * This is the grammar used in the implementation below.
 */
PiTerm<String> term() : {
    PiTerm<String> tm0, tm1;
    ArrayList<String> names;
    ArrayList<LambdaTerm<String>> exps;
    ArrayList<PiTerm<String>> tmList;
    Token n;
} {
    LOOKAHEAD(2)
    n=<ID> "(" names=receCont() "." tm0=term()
    {
        return new Receive<String>(n.toString(), names, tm0);
    }
    |
    n=<ID> "<" exps=sendCont() "." tm0=term()
    {
        return new Send<String>(n.toString(), exps, tm0);
    }
    |
    "[" tm0=paraCont()
    {
        return tm0;
    }
    |
    "new" n=<ID> "in" tm0=term()
    {
        return new Restrict<String>(n.toString(), tm0);
    }
    |
    "!" tm0=term()
    {
        return new Replicate<String>(tm0);
    }
    |
    "{" tm0=term() "+" tm1=term() tmList=sumCont()
    {
        tmList.add(0, tm1);
        tmList.add(0, tm0);
        return new NDSum(tmList);
    }
    |
    "0"
    {
        return new Parallel<String>(new ArrayList<PiTerm<String>>());
    }
}

ArrayList<PiTerm<String>> sumCont() : {
    PiTerm<String> tm;
    ArrayList<PiTerm<String>> tmList;
} {
    "}"
    {
        return new ArrayList<PiTerm<String>>();
    }
    |
    "+" tm=term() tmList=sumCont()
    {
        tmList.add(0, tm);
        return tmList;
    }
}

PiTerm<String> paraCont() : {
    PiTerm<String> e;
    ArrayList<PiTerm<String>> rest;
} {
    "]"
    {
        return new Parallel<String>(new ArrayList<PiTerm<String>>());
    }
    |
    e=term() rest=paraContCont()
    {
        rest.add(0, e);
        return new Parallel<String>(rest);
    }
}

ArrayList<PiTerm<String>> paraContCont() : {
    PiTerm<String> e;
    ArrayList<PiTerm<String>> rest;
} {
    "]"
    {
        return new ArrayList<PiTerm<String>>();
    }
    |
    "|" e=term() rest=paraContCont()
    {
        rest.add(0, e);
        return rest;
    }
}

ArrayList<LambdaTerm<String>> sendCont() : {
    LambdaTerm<String> lam;
    ArrayList<LambdaTerm<String>> rest;
} {
    ">"
    {
        return new ArrayList<LambdaTerm<String>>();
    }
    |
    lam=lamTerm() rest=sendContCont()
    {
        rest.add(0, lam);
        return rest;
    }
}

ArrayList<LambdaTerm<String>> sendContCont() : {
    LambdaTerm<String> lam;
    ArrayList<LambdaTerm<String>> rest;
} {
    ">"
    {
        return new ArrayList<LambdaTerm<String>>();
    }
    |
    "," lam=lamTerm() rest=sendContCont()
    {
        rest.add(0, lam);
        return rest;
    }
}

ArrayList<String> receCont() : {
    Token n;
    ArrayList<String> rest;
} {
    ")"
    {
        return new ArrayList<String>();
    }
    |
    n=<ID> rest=receContCont()
    {
        rest.add(0, n.toString());
        return rest;
    }
}

ArrayList<String> receContCont() : {
    Token n;
    ArrayList<String> rest;
} {
    ")"
    {
        return new ArrayList<String>();
    }
    |
    "," n=<ID> rest=receContCont()
    {
        rest.add(0, n.toString());
        return rest;
    }
}

LambdaTerm<String> lamTerm() : {
    Token n;
    LambdaTerm<String> lam0, lam1;
} {
    LOOKAHEAD(2)
    "\\" n=<ID> "->" lam0=lamTerm()
    {
        return new Abstraction<String>(n.toString(), lam0);
    }
    |
    n=<ID> lam0=lamTermOpt()
    {
        if(lam0 != null) {
            return new Application<String>(
                    new Variable<String>(n.toString()), lam0);
        }
        else { return new Variable<String>(n.toString()); }
    }
    |
    "(" lam0=lamTerm() ")" lam1=lamTermOpt()
    {
        if(lam1 != null) { return new Application<String>(lam0, lam1); }
        else { return lam0; }
    }
}

LambdaTerm<String> lamTermOpt() : {
    LambdaTerm<String> lam;
} {
    lam=lamTerm()
    {
        return lam;
    }
    |
    {}
    {
        return null;
    }
}
