PARSER_BEGIN(Parser)
package parser;

import parsersyntax.*;
import java.io.File;
import java.io.InputStream;
import java.io.FileInputStream;
import java.io.FileNotFoundException;

public class Parser {

    /**
     * Parse some input to obtain an AST.
     * @param input a java.io.InputStream containing text (ideally) representing
     * a japi program
     * @return an AST (a Term object) representing the parsed program
     * @throws ParseException if the input could not be parsed (i.e. if there
     * was a syntax error in the program)
     */
    public static Term parseStream(InputStream input) throws ParseException {
        return new Parser(input).expression();
    }
}

PARSER_END(Parser)

SKIP :
    { " "
    | "\t"
    | "\n"
    | "\r"
    | <"//" (~["\n","\r"])* ("\n" | "\r" | "\r\n")>
    | <"/*" (~[])* "*/">
    }

TOKEN :
    { "<"
    | ">"
    | "("
    | ")"
    | "."
    | "["
    | "|"
    | "]"
    | "new"
    | "in"
    | "!"
    | "0"
    | <ID: (["a"-"z"])+>
    }

void input() : {} { expression() <EOF> }

/* The pi-calculus grammar used is as follows:
 *
 *     P ::= "x(a0, a1, ... aN).P" | "x<a0, a1, ... aN>.P" | "[P0|P1|...PN]"
 *         | "new x in P" | "!P" | "0"
 *
 * which, in more concrete notation is:
 *
 *     P ::= "x(R.P" | "x<S.P" | "[P|PQ" | "new x in P" | "!P" | "0"
 *     Q ::= "]" | "|PQ"
 *     R ::= ")" | "yR'"
 *     R'::= ")" | ", yR'"
 *     S ::= ">" | "yS'"
 *     S'::= ">" | ", yS'"
 *
 * This is the grammar used in the implementation below.
 */
Term expression() : { Term e1, e2, e3; Token n1, n2; }
{
    LOOKAHEAD(2)
    n1=<ID> "(" n2=<ID> ")" "." e1=expression()
    {
        return new Receive(n1.toString(), n2.toString(), e1);
    }
    |
    n1=<ID> "<" n2=<ID> ">" "." e1=expression()
    {
        return new Send(n1.toString(), n2.toString(), e1);
    }
    |
    "[" e1=expression() "|" e2=expression() e3=parallelCont()
    {
        if(e3 == null) {
            return new Parallel(e1, e2);
        }
        else {
            return new Parallel(e1, new Parallel(e2, e3));
        }
    }
    |
    "new" n1=<ID> "in" e1=expression()
    {
        return new Restrict(n1.toString(), e1);
    }
    |
    "!" e1=expression()
    {
        return new Replicate(e1);
    }
    |
    "0"
    {
        return new End();
    }
}

Term parallelCont() : { Term e1, e2; }
{
    "|" e1=expression() e2=parallelCont()
    {
        return (e2 == null) ? e1 : new Parallel(e1, e2);
    }
    |
    "]"
    {
        return null;
    }
}

Term sendCont() : { Token n; }
{
}

Term receiveCont() : { Token n; }
{
}
